Single Unified Architecture



flowchart LR
  %% ====== CLIENTS ======
  subgraph Slack_Client["Slack Client (Workspace)"]
    H[Home Tab]
    Mod[Modals (Intake, Review, Confirm)]
    SC[/Slash Commands/]
    SHT[(Shortcuts)]
    FH[File Hub View]
  end

  %% ====== EDGE ======
  subgraph Edge["HTTP Edge and Slack Adapter"]
    API[Events and Interactions API\n(Bolt + Fastify)]
  end

  %% ====== PLATFORM CORE ======
  subgraph Platform["Platform Core (Shared Services)"]
    ORC[Workflow Orchestrator\n(sagas, retries, approvals, idempotency)]
    POL[Policy and Guardrails\n(naming, privacy, retention)]
    AI["AI Engine\n(prompting, schema enforcement, routing)"]
    SGW[SlackGateway\n(typed Web API, rate-safe, idempotent)]
    Q[(Queue)]
    REDIS[(Redis cache and locks)]
    DB[(PostgreSQL and pgvector)]
    S3[(Artifact Storage)]
    OBS[(Observability and Audit)]
    DLP[(Optional DLP)]
  end

  %% ====== DOMAINS ======
  subgraph StructureDomain["Structure Domain (User Story 1)"]
    JOB[JobService]
    GEN[Generator]
    VAL[Validator]
    APP[ApplyService]
  end

  subgraph FileHubDomain["File Hub Domain (User Story 2)"]
    FJ[FileJob Manager]
    DEDUPE[DeduplicationEngine]
    TAG[TaggingEngine]
    SRC[SearchService]
  end

  %% ====== PROVIDERS ======
  subgraph Providers["Model and Search Providers"]
    LLM[(Model Provider)]
    EXT[(External Search API optional)]
  end

  %% ====== CLIENT to EDGE ======
  H <--> API
  Mod <--> API
  SC --> API
  SHT --> API
  FH <--> API

  %% ====== EDGE to PLATFORM ======
  API --> ORC
  API --> OBS

  %% ====== SHARED CROSS-CUTS ======
  ORC --> POL
  ORC <--> REDIS
  ORC --> Q
  ORC --> OBS
  ORC --> DLP

  %% ====== STRUCTURE FLOW ======
  ORC -->|structure workflow| JOB
  JOB -->|build prompt| GEN
  GEN --> AI
  AI --> LLM
  GEN --> VAL
  VAL --> POL
  VAL --> DB
  JOB -->|render review blocks| API
  JOB -->|persist state| DB
  JOB -->|artifacts| S3
  JOB -->|apply plan| APP
  APP --> SGW
  APP --> DB
  SGW --> OBS

  %% ====== FILE HUB FLOW ======
  ORC -->|file workflow| FJ
  FJ -->|harvest files| SGW
  FJ --> DB
  FJ --> DEDUPE
  DEDUPE --> DB
  FJ --> TAG
  TAG --> AI
  AI --> LLM
  TAG --> DB
  TAG -->|embeddings| DB
  FJ --> SRC
  SRC --> DB
  SRC --> EXT
  FJ -->|artifacts| S3
  FJ --> OBS


This diagram shows how all parts of the system connect together. Slack users interact with the system through the Home Tab, Modals, Shortcuts, Slash Commands, and the File Hub view. All those inputs go through a single gateway called the Slack Events and Interactions API. That gateway connects to a central platform that manages everything the system does. The platform includes an Orchestrator that runs the workflows, a Policy service that checks for naming and privacy rules, an AI Engine that creates and validates content, and a Slack Gateway that safely sends data back to Slack. The data layer includes PostgreSQL with pgvector for storing information and search indexes, Redis for quick caching and locking, S3 for saving files and artifacts, and tools for logging and observability. There are two main application areas. The first one is the Structure Domain, which builds and applies organized Slack workspace structures. The second one is the File Hub Domain, which collects, tags, and makes project files easy to find. Both of these areas use the same shared platform.
The key idea behind this design is that everything passes through one reliable core instead of building separate systems for each feature. By sharing the Orchestrator, Policy, AI Engine, and Slack Gateway, we can reuse the same logic for retries, validation, approvals, and error handling. This helps keep the code simpler and easier to maintain. Each domain focuses only on its specific work and uses the shared tools to do so. The Slack Gateway ensures all operations are safe, rate-limited, and recoverable if something fails. Using PostgreSQL and pgvector gives us both structured data storage and advanced search, while Redis and the Queue help balance the load. This setup is simple enough for small teams now but is modular enough to grow into separate services later if needed.
LLM (GPT 5) Chatlog: https://chatgpt.com/share/68f9750e-3bac-800a-8ec6-d6ffefd4276c 
